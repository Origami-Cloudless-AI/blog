[
  {
    "objectID": "posts/2022-12-29-people_count_in_room.nbconvert.html",
    "href": "posts/2022-12-29-people_count_in_room.nbconvert.html",
    "title": "Privacy-preserving occupancy counting with Linear Regression",
    "section": "",
    "text": "Previously I have worked on TinyML as-a-Service project, running Machine Learing (ML) inferences on microcontrollers in tiny IoT sensors, which unlock the power of ML without Cloud computing. I have been looking for a TinyML killer usecase in real life. One of such usecases may be a privacy-preserving occupancy count device. Although occupancy counting itself can be done with camera devices, it uploads enomous amount of raw data of recordings on Cloud. Then, those data is proccessed heavily by ML on Cloud GPU. Basically We don’t want to expose our privacy data out of our premises. Uploading onto Cloud always has a risk of leaking such data, compared with local processing within sensor devices. Uploading also comes with communication cost, for example, via 5G cellular. My proposal is to enable “people counting in a room with a IoT sensor”. ML inference on IoT deivce processes primitive raw data (ex: CO2 emission) locally to detect number of people in a room. People emits CO2. The potential customers of this device may be building maintenance companies (i.e. smart building).They could:\n\nmaximize room usage rate by allocating suitable spaces for group of people\nreduce energy consumption by controlling lights bulbs and air conditioners for group of people\n\nIn shared sauna (yes, here’s Finland), for example, the current space availability could be checked online before you go naked. In sauna, people are naked and they can talk about thier secrets in relaxed mood. So privacy matters a lot and we don’t want any real sensors installed at all. Probably measuring CO2 emission is acceptable in most of the places. This IoT sensor could be also used to check if your eldery parents are still breathing in your home town. This TinyML device may have bluetooth or Wi-fi connection to send only a single 1 byte of data(number of people, 0-256) occassionally, compared with Giga byte of recording data. This pre-processed information (number of people) doesn’t include privacy and uploading cost is cheap. ## Problem Formulation  CO2 sensor in a room measures how much CO2 in a room as time passes. ML would detect number of people in a room with amount of CO2. Here’s a Kaggle dataset. This dataset is composed of several sensor data. They are CO2, lights on/off, temperature, motion detector and sound. The datapoint is considered state of a room at certain time. I picked up amount of CO2 emission as a main feature. The rest of sensor data could be used too to complement if CO2 is not enough. The label is number of people in a room. The fewer sensors used, the better for TinyML because of the limited computational resources on microcontrollers. We will evaluate the different number of feature set. How to shrink ML model in microcontroller is out of this course scope."
  },
  {
    "objectID": "posts/2022-12-29-people_count_in_room.nbconvert.html#method",
    "href": "posts/2022-12-29-people_count_in_room.nbconvert.html#method",
    "title": "Privacy-preserving occupancy counting with Linear Regression",
    "section": "Method",
    "text": "Method\nWe will discuss Datapoints, Feature selection, Model, Loss function and Validation below.\n\nDatapoints\n\nThe size of a room is 6m x 4.6m. The number of datapoints is 10,129 without any missing values. 7 sensor nodes transmit almost every 30s via wireless transceivers. Each attribute of sensors: - Date: YYYY/MM/DD - Time: HH:MM:SS - Temperature: In degree Celsius (S1_Temp, S2_Temp, S3_Temp) - Light: In Lux (S1_Light, S2_Light, S3_Light, S4_Light) - Sound: In Volts (amplifier output read by ADC) (S1_Sound, S2_Sound, S3_Sound, S4_Sound) - CO2: In PPM (S5_CO2) - CO2 Slope: Slope of CO2 values taken in a sliding window (S5_CO2_Slope) - PIR: Binary value conveying motion detection (S6_PIR, S7_PIR) - RoomOccupancyCount: Ground Truth (Room_Occupancy_Count)\n\n\nCode\ndf = pd.read_csv('https://raw.githubusercontent.com/doyu/people_count_in_room/main/Occupancy_Estimation.csv')\n\n\n\n\nCode\ndf.iloc[:,:10].head()\n\n\n\n\n\n\n  \n    \n      \n      Date\n      Time\n      S1_Temp\n      S2_Temp\n      S3_Temp\n      S4_Temp\n      S1_Light\n      S2_Light\n      S3_Light\n      S4_Light\n    \n  \n  \n    \n      0\n      2017/12/22\n      10:49:41\n      24.94\n      24.75\n      24.56\n      25.38\n      121\n      34\n      53\n      40\n    \n    \n      1\n      2017/12/22\n      10:50:12\n      24.94\n      24.75\n      24.56\n      25.44\n      121\n      33\n      53\n      40\n    \n    \n      2\n      2017/12/22\n      10:50:42\n      25.00\n      24.75\n      24.50\n      25.44\n      121\n      34\n      53\n      40\n    \n    \n      3\n      2017/12/22\n      10:51:13\n      25.00\n      24.75\n      24.56\n      25.44\n      121\n      34\n      53\n      40\n    \n    \n      4\n      2017/12/22\n      10:51:44\n      25.00\n      24.75\n      24.56\n      25.44\n      121\n      34\n      54\n      40\n    \n  \n\n\n\n\n\n\nCode\ndf.rename(columns={'Room_Occupancy_Count':'Target'}).iloc[:,10:].head()\n#df.iloc[:,10:].head()\n\n\n\n\n\n\n  \n    \n      \n      S1_Sound\n      S2_Sound\n      S3_Sound\n      S4_Sound\n      S5_CO2\n      S5_CO2_Slope\n      S6_PIR\n      S7_PIR\n      Target\n    \n  \n  \n    \n      0\n      0.08\n      0.19\n      0.06\n      0.06\n      390\n      0.769231\n      0\n      0\n      1\n    \n    \n      1\n      0.93\n      0.05\n      0.06\n      0.06\n      390\n      0.646154\n      0\n      0\n      1\n    \n    \n      2\n      0.43\n      0.11\n      0.08\n      0.06\n      390\n      0.519231\n      0\n      0\n      1\n    \n    \n      3\n      0.41\n      0.10\n      0.10\n      0.09\n      390\n      0.388462\n      0\n      0\n      1\n    \n    \n      4\n      0.18\n      0.06\n      0.06\n      0.06\n      390\n      0.253846\n      0\n      0\n      1\n    \n  \n\n\n\n\n\n\nCode\n#df.info()\n\n\n\n\nCode\n#profile = ProfileReport(df)\n#profile\n#profile.to_file(\"Analysis.html\")\n\n\n\n\nFeature selection\nAs seen below, all of 3 temperature sensors are correlated so that only S1_Temp, which is most correlated to target, was chosen. All of 3 light sensors are correlated so that only S1_Light, which is most correlated to target, was chosen. All of sound sensors are dropped here because of privacy reason. We started with S1_Temp, S1_Light, S5_CO2, S5_CO2_Slope, S6_PIR, and S7_PIR.\n\n\nCode\n#df.corr()\n\n\n\n\nCode\nsns.heatmap(df.rename(columns={'Room_Occupancy_Count':'target'}).corr())\n\n\n<AxesSubplot:>\n\n\n\n\n\n\n\nCode\n#df.columns\ndf = df[['S1_Temp', 'S1_Light', 'S5_CO2', 'S5_CO2_Slope', 'S6_PIR', 'S7_PIR', 'Room_Occupancy_Count']]\ndf.head()\n\n\n\n\n\n\n  \n    \n      \n      S1_Temp\n      S1_Light\n      S5_CO2\n      S5_CO2_Slope\n      S6_PIR\n      S7_PIR\n      Room_Occupancy_Count\n    \n  \n  \n    \n      0\n      24.94\n      121\n      390\n      0.769231\n      0\n      0\n      1\n    \n    \n      1\n      24.94\n      121\n      390\n      0.646154\n      0\n      0\n      1\n    \n    \n      2\n      25.00\n      121\n      390\n      0.519231\n      0\n      0\n      1\n    \n    \n      3\n      25.00\n      121\n      390\n      0.388462\n      0\n      0\n      1\n    \n    \n      4\n      25.00\n      121\n      390\n      0.253846\n      0\n      0\n      1\n    \n  \n\n\n\n\nWe split feature set into 6 groups X6, X5, X4, X3, X2 and X1. The number shows how many features are included in those X feature set. Each group includes:\n\n\nCode\nX6 = df[['S1_Temp', 'S1_Light', 'S5_CO2', 'S5_CO2_Slope', 'S6_PIR', 'S7_PIR']]\nX5 = df[['S1_Temp', 'S5_CO2', 'S5_CO2_Slope', 'S6_PIR', 'S7_PIR']]\nX4 = df[['S1_Temp', 'S5_CO2', 'S5_CO2_Slope', 'S6_PIR']]\nX3 = df[['S5_CO2', 'S5_CO2_Slope', 'S6_PIR']]\nX2 = df[['S5_CO2', 'S5_CO2_Slope']]\nX1 = df[['S5_CO2']]\n\nfor i, x in enumerate([X6, X5, X4, X3, X2, X1]):\n    features = \", \".join(x.columns)\n    print(f\"X{6-i}: {features}\")\n\n\nX6: S1_Temp, S1_Light, S5_CO2, S5_CO2_Slope, S6_PIR, S7_PIR\nX5: S1_Temp, S5_CO2, S5_CO2_Slope, S6_PIR, S7_PIR\nX4: S1_Temp, S5_CO2, S5_CO2_Slope, S6_PIR\nX3: S5_CO2, S5_CO2_Slope, S6_PIR\nX2: S5_CO2, S5_CO2_Slope\nX1: S5_CO2\n\n\n\n\nModel\n\nWe applied linear regression to detect the number of people in a room from various sensor data. It is because the above correlation map showed apparent correlation between features and target. Also linear regression is relatively lighter computation than other method like deep neural network. This is good for TinyML. We run linear regression over different polynomial degree from 1 to 6 against different feature set, X1 to X6. Then, we picked up the best polynomial degree for each feature set and compared their accuracy. 30 patterns of 6 dataset groups with 5 polynomial dgrees are investigated here.\n\n\nCode\n#%%timeit\ndef poly_scores(degrees, X, y):\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\n    scores = []\n    for i in degrees:\n        model = LinearRegression(fit_intercept=False)\n        poly = PolynomialFeatures(degree=i)\n        skf = StratifiedKFold()\n        x = cross_val_score(model, poly.fit_transform(X_train), y_train, cv=skf)\n        #print(i, x)\n        scores.append(np.mean(x))\n\n    return scores\n\ndef test_accuracy(degree, X, y):\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\n    poly = PolynomialFeatures(degree=degree)\n    X_train_poly = poly.fit_transform(X_train)\n    model = LinearRegression(fit_intercept=False).fit(X_train_poly, y_train)\n    y = model.predict(poly.fit_transform(X_test))\n    y = list(map(round, y))\n    return sum(y==y_test) / len(y)\n\n\n\n\nCode\n# 'S1_Temp', 'S1_Light', 'S5_CO2', 'S5_CO2_Slope', 'S6_PIR', 'S7_PIR'\ny = df['Room_Occupancy_Count']\n\ndegrees = range(1,6)\nscores = {'poly degree':degrees}\naccs = []\n\nfor i, X in enumerate([X6, X5, X4, X3, X2, X1]):\n    tmp = poly_scores(degrees, X, y)\n    scores[f\"X{6-i}\"] = tmp\n    idx = np.argmax(tmp)\n    #print(idx, degrees[idx])\n    acc = test_accuracy(degrees[idx], X, y)\n    accs.append(acc)\n\n\n\n\nCode\nd = pd.DataFrame({k: pd.Series(v) for k, v in scores.items()})\nd = d.set_index('poly degree')\nd\n#d.style.applymap(lambda x: \"background-color: yellow\" if x==np.max(d['score']) else \"background-color: white\")\n\n\n\n\n\n\n  \n    \n      \n      X6\n      X5\n      X4\n      X3\n      X2\n      X1\n    \n    \n      poly degree\n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      1\n      0.870882\n      0.834788\n      0.817154\n      0.796813\n      0.751911\n      0.445135\n    \n    \n      2\n      0.936174\n      0.865012\n      0.837572\n      0.820712\n      0.767796\n      0.452824\n    \n    \n      3\n      0.955366\n      0.899802\n      0.875181\n      0.839125\n      0.799765\n      0.461071\n    \n    \n      4\n      0.949246\n      0.886663\n      0.882610\n      0.841926\n      0.813125\n      0.461860\n    \n    \n      5\n      0.790045\n      0.642105\n      0.761449\n      0.502662\n      0.807503\n      0.459508\n    \n  \n\n\n\n\n\n\nCode\nd.plot(xlabel='poly degree', ylabel='coefficient of determination', figsize=(8,2))\n\n\n<AxesSubplot:xlabel='poly degree', ylabel='coefficient of determination'>\n\n\n\n\n\n\n\nLoss function\n\nMean squared error (MSE) was used to evaluate estimation error because it’s most straightforward for this simple model with many combinations of features and polynomial degrees.\n\n\nValidation\n\nAt first, 30% of data is reserved for final evaluation, testing. Then, we split the rest of data into training and validation to find out hyperparameters(e.g. polynonial degrees). As seen below, taret value is not equally scattered. So we used Stratifield KFold cross validation to keep the same ratio of labels in each validation. The split group number is 5.\n\n\nCode\ntarget = 'Room_Occupancy_Count'\n#df[target].hist(figsize=(10,5))\ndf[target].hist(figsize=(10,2))\n\n\n<AxesSubplot:>\n\n\n\n\n\nHere is a final accuracy comparison between X1 to X6 feeature set."
  },
  {
    "objectID": "posts/2022-12-29-people_count_in_room.nbconvert.html#result",
    "href": "posts/2022-12-29-people_count_in_room.nbconvert.html#result",
    "title": "Privacy-preserving occupancy counting with Linear Regression",
    "section": "Result",
    "text": "Result\nAs seen below, if we use only X1:CO2, the prediction accuracy dropped drastically. Using 2 features, X2: CO2 and CO2_Slope with polynomial degree 4 may be reasonable choice. Using 2 features doesn’t require a lot of initial investment of installing sensors in the field and also computation with polynomial degree 4 is smaller on TinyML sensor device. This basically depends on the requirements, how much accuracy is needed, how small TinyML device is and so on. In the future, more powerful TinyML device will be shipped, where we could investigate more complicated model on such devices.\n\n\nCode\nd = {k: v for k, v in zip(['X6','X5','X4','X3','X2','X1'], accs)} \nd = pd.DataFrame({k: v for k, v in d.items()}, index=['accuracy'])\nd\n\n\n\n\n\n\n  \n    \n      \n      X6\n      X5\n      X4\n      X3\n      X2\n      X1\n    \n  \n  \n    \n      accuracy\n      0.977624\n      0.925962\n      0.92333\n      0.9026\n      0.890424\n      0.737743\n    \n  \n\n\n\n\n\n\nCode\nd.T.plot(figsize=(8,2), grid=True)\n\n\n<AxesSubplot:>"
  },
  {
    "objectID": "posts/2022-12-29-people_count_in_room.nbconvert.html#conclusion",
    "href": "posts/2022-12-29-people_count_in_room.nbconvert.html#conclusion",
    "title": "Privacy-preserving occupancy counting with Linear Regression",
    "section": "Conclusion",
    "text": "Conclusion\nWe have examined how accurate to predict the number of people in a room with variety of sensor data combination, with the help of Machine Learning, more specifically, with polynomial regression. Only with CO2 emission and CO2 moving average, counting the number of people in a room achieved around 90% of accuracy. Altbhough this seems be useful, this really depends on the size of a room in use or number of sensors install in the place. This could be some reference to plan this occupancy counting in the real field. The further experiment in the real environment would be necessary. For example, with different number of sensors, with different location of sensor installation, with different TinyML sensor devices."
  },
  {
    "objectID": "posts/2022-12-29-people_count_in_room.nbconvert.html#references",
    "href": "posts/2022-12-29-people_count_in_room.nbconvert.html#references",
    "title": "Privacy-preserving occupancy counting with Linear Regression",
    "section": "References",
    "text": "References\n\ndataset, https://www.kaggle.com/ananthr1/room-occupancy-estimation-data-set\nnotebook, https://github.com/doyu/people_count_in_room/blob/main/people_count_in_room.ipynb"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Origami@NEXUS",
    "section": "",
    "text": "Privacy-preserving occupancy counting with Linear Regression\n\n\n\n\n\n\n\nUseCase\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nDec 29, 2022\n\n\nHiroshi Doyu\n\n\n\n\n\n\n  \n\n\n\n\nPost With Code\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nDec 29, 2022\n\n\nHarlow Malloc\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nDec 26, 2022\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  }
]